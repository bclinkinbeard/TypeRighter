// Generated by CoffeeScript 1.3.3

describe("TypeRighter", function() {
  var authorClass, callback, commitClass, committerClass, tr, urlClass;
  tr = void 0;
  commitClass = void 0;
  authorClass = void 0;
  committerClass = void 0;
  urlClass = void 0;
  callback = void 0;
  beforeEach(function() {
    var Author, Commit, Committer, Url;
    tr = new TypeRighter();
    commitClass = Commit = (function() {

      function Commit() {}

      return Commit;

    })();
    authorClass = Author = (function() {

      function Author() {}

      return Author;

    })();
    committerClass = Committer = (function() {

      function Committer() {}

      return Committer;

    })();
    return urlClass = Url = (function() {

      function Url() {}

      return Url;

    })();
  });
  it("should instantiate", function() {
    return expect(tr).toBeDefined();
  });
  it("should clear path registry when reset is called", function() {
    var registry;
    registry = tr._pathRegistry;
    tr.reset();
    return expect(registry).not.toBe(tr._pathRegistry);
  });
  describe("registering paths", function() {
    beforeEach(function() {
      tr.reset();
      return callback = function() {};
    });
    it("should add a single path", function() {
      var path;
      path = 'foo';
      tr.registerPath(path, callback);
      expect(tr.getCallbacksForPath(path).length).toBe(1);
      return expect(tr.getCallbacksForPath(path)[0]).toBe(callback);
    });
    it("should add an array of paths", function() {
      var paths;
      paths = ['foo', 'bar'];
      tr.registerPath(paths, callback);
      expect(tr.getCallbacksForPath(paths[0]).length).toBe(1);
      expect(tr.getCallbacksForPath(paths[0])).toContain(callback);
      expect(tr.getCallbacksForPath(paths[1]).length).toBe(1);
      return expect(tr.getCallbacksForPath(paths[1])).toContain(callback);
    });
    return it("should add a comma separated list of paths", function() {
      var paths;
      paths = 'foo, bar';
      tr.registerPath(paths, callback);
      expect(tr.getCallbacksForPath('foo').length).toBe(1);
      expect(tr.getCallbacksForPath('foo')).toContain(callback);
      expect(tr.getCallbacksForPath('bar').length).toBe(1);
      return expect(tr.getCallbacksForPath('bar')).toContain(callback);
    });
  });
  describe("calling callbacks", function() {
    return it("should pass proper values to callbacks", function() {
      var target;
      target = {};
      target.callback = function(value, key, scope) {};
      spyOn(target, 'callback');
      tr.registerPath('commit.committer.name', target.callback);
      tr.parse(commits);
      return expect(target.callback).toHaveBeenCalledWith(commits[0].commit.committer.name, 'name', commits[0].commit.committer);
    });
  });
  describe("TypeRighter.replaceWith()", function() {
    it("should replace a value with the value passed to replaceWith", function() {
      var newName;
      newName = 'Willy Wonka';
      tr.registerPath('commit.committer.name', TypeRighter.replaceWith(newName));
      tr.parse(commits);
      return expect(commits[0].commit.committer.name).toBe(newName);
    });
    return it("should invoke a function passed to replaceWith", function() {
      var target;
      target = {};
      target.replaceFunc = function(value, key, scope) {
        return 'Santa Claus';
      };
      spyOn(target, 'replaceFunc').andCallThrough();
      tr.registerPath('commit.committer.name', TypeRighter.replaceWith(target.replaceFunc));
      tr.parse(commits);
      return expect(commits[0].commit.committer.name).toBe('Santa Claus');
    });
  });
  return describe("TypeRighter.type() and path matching", function() {
    it("should match an empty string to root array members", function() {
      tr.registerPath('', TypeRighter.type(commitClass));
      tr.registerPath('address', TypeRighter.type(commitClass));
      tr.parse(commits);
      return expect(commits[0] instanceof commitClass).toBeTruthy();
    });
    it("should match a simple property name to all occurrences in hierarchy", function() {
      tr.registerPath('author', TypeRighter.type(authorClass));
      tr.parse(commits);
      expect(commits[0].author instanceof authorClass).toBeTruthy();
      return expect(commits[0].commit.author instanceof authorClass).toBeTruthy();
    });
    it("should match a dot notated path name", function() {
      tr.registerPath('commit.committer', TypeRighter.type(committerClass));
      tr.parse(commits);
      expect(commits[0].committer instanceof committerClass).toBeFalsy();
      return expect(commits[0].commit.committer instanceof committerClass).toBeTruthy();
    });
    return it("should match a set of paths", function() {
      tr.registerPath(['avatar_url', 'url'], TypeRighter.type(urlClass));
      tr.parse(commits);
      expect(commits[0].author.avatar_url instanceof urlClass).toBeTruthy();
      expect(commits[0].author.url instanceof urlClass).toBeTruthy();
      expect(commits[0].commit.url instanceof urlClass).toBeTruthy();
      return expect(commits[0].committer.avatar_url instanceof urlClass).toBeTruthy();
    });
  });
});
